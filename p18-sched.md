## Scheduler

Previous part started two processes but when we pressed "Ctrl+P", we note that
actually only the first process is running all the time. This situation is
referred to as *starvation*: the second process is *starved* for CPU resources.
Such an OS is *not fair* to its processes. 

In this part, we make our OS *switch* between processes. To do this, we first 
re-enable the timer in `lapic.c`. Next, when the timer interrupt comes, we call 
`yield` from `trap.c` which sets the currently running process as `RUNNABLE`.
`yield` in turn calls `sched` which switches the context from the current
process to CPU scheduler `c->scheduler` which will start another `RUNNABLE`
process. 

The magic of context switch happens in `swtch.S`. We either call `swtch` to go 
from a process to scheduler or from scheduler to a process. The overall idea is
to save the existing context (CPU registers) onto its kernel stack, switch the
kernel stack to the new context, and restore CPU registers that we might have
saved earlier.

When we call `switch`, from GCC calling convention many *caller-save registers*
like `eax`, `eip` etc are saved on the stack. The code for this is generated by
the compiler. If we search `swtch` in `kernel.asm`, we see the following code:

```
  1014a3:	50                   	push   %eax
  1014a4:	52                   	push   %edx
  1014a5:	e8 16 32 00 00       	call   1046c0 <swtch>
```

`eax` and `edx` registers are pushed on the stack. `eip` will be saved as the 
return address by the `call` instruction itself. Interestingly, `ecx` is also a
caller-saved register, but since the callee of `swtch`, i.e, `scheduler`, did
not modify `ecx`, the compiler chose to not save it. Caller of `scheduler` would
have already saved it.

`swtch` saves rest of the *callee-save registers* (ebp, ebx, esi, edi) on to the
stack. It then saves the current stack pointer into the old context and switches
the stack pointer to the new context. Then it starts popping the same
callee-saved registers which will now be restored from the new stack. Finally,
when it calls `ret`, it returns back to `scheduler` since `ret` restores the
instruction pointer to the saved return address.

Putting it all together:
1. OS called pinit to initialize a process after booting
2. This initial process' kernel stack was setup. 
   1. Kernel stack starts with a `trapframe` which will be later used by the
   hardware to save and restore all the registers used by the user program.
   2. Segment selectors for the user program are set up in the `trapframe`.
   3. `trapframe` is followed by `context` which is all initiliazed to zero
   except `eip` which is set to `trapret`.
3. OS called scheduler. Scheduler found the runnable process and called `swtch`. 
   1. `swtch` saves the registers in the currently executing stack and switch to
   the kernel stack of the user program.
4. When `swtch` returns, the control jumps to `trapret` as this was saved as `eip`
   in the new process' context. `trapret` sets up segment selectors. And finally 
   calls `iret` which jumps to the user program. CPU is now running ring 3.
5. User program runs doing whatever it wants with non-privileged CPU registers.
6. Timer interrupt happens
   1. Hardware looks up the kernel stack position using TSS->esp0.
   2. Hardware pushes stack selector, stack pointer, eflags, and code selector,
   eip, error code, trapno to kernel stack.
   3. Hardware jumps to `alltraps` as it is the trap handler set by the OS in IDT. 
   CPU is now running in ring 0.
   4. `alltraps` saves the segment selectors, user program registers including
   general purpose registers and calls `trap` in `trap.c`.
   5. `trap` handler calls `yield` which switches to context saved by the scheduler. 
7. Scheduler continues where it left off and looks for the next runnable process.
8. Later when the process is picked again by the scheduler, the process continues 
   where it left off, that is returning from `swtch` to `sched` to `yield` to `trap`
   to `trapret` which finally runs the user process again.
9. User program continues doing what it was doing unaware of what happened in
the meantime :)

This scheduler implementation is called *round-robin*. If we now press Ctrl+P
after booting the OS, we will see that sometimes process 1 is running and
sometimes process 2 is running:

```
1 run    initcode
2 runble initcode
1 runble initcode
2 run    initcode
```